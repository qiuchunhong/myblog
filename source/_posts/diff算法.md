---
title: diff算法
categories: diff算法
tags: [js] #文章标签，可空，多标签请用格式，注意:后面有个空格
summary: Vue中的DOM-Diff算法：patch过程
---

## VNode的作用
> 我们在视图渲染之前，把写好的template模板先编译成VNode并缓存下来，等到数据发生变化页面需要重新渲染的时候，我们把数据发生变化后生成的VNode与前一次缓存下来的VNode进行对比，找出差异，然后有差异的VNode对应的真实DOM节点就是需要重新渲染的节点，最后根据有差异的VNode创建出真实的DOM节点再插入到视图中，最终完成一次视图更新。

## patch
> 如果新的VNode上有节点，而旧的oldVNode上没有，就在旧的oldVNode上加上去；如果新的VNode上没有，而旧的oldVNode上有，在旧的oldVNode上减去；如果某些节点，新的VNode跟旧的oldVNode都有，就更新旧的oldVNode使新旧一样。

> 以新的VNode为基准，改造旧的oldVNode使之成为跟新的VNode一样，这就是patch过程要干的事。

说了这么多，听起来感觉好像很复杂的样子，其实不然，我们仔细想想，整个patch无非就是干三件事：

- 创建节点：新的VNode中有而旧的oldVNode中没有，就在旧的oldVNode中创建。 
- 删除节点：新的VNode中没有而旧的oldVNode中有，就从旧的oldVNode中删除。
- 更新节点：新的VNode和旧的oldVNode中都有，就以新的VNode为准，更新旧的oldVNode。


> 新创建的节点插入到所有未处理节点之前，而并非所有已处理节点之后。



### 静态节点
```javascript
<p>我是不会变化的文字</p>
```
上面这个节点里面只包含了纯文字，没有任何可变的变量，这也就是说，不管数据再怎么变化，只要这个节点第一次渲染了，那么它以后就永远不会发生变化，这是因为它不包含任何变量，所以数据发生任何变化都与它无关。我们把这种节点称之为静态节点。

## 更新节点
- 新节点跟旧节点是否都是静态节点，如果都是静态节点则跳过，不进行处理。
- 如果新节点是文本节点，判断旧节点如果也是文本节点，则对比两个节点，将旧节点的内容改变为新节点的内容。如果旧节点不是文本节点，则不管旧节点里面是什么都用新节点里面的文本替换掉旧节点中的内容。
- 如果新节点是元素节点，则需要判断是否有子节点
	- 有子节点：判断旧节点是否有子节点，如果有递归对比新旧节点。如果旧节点没有子节点，则将新节点的内容添加到旧节点中去。
	- 没有子节点：元素节点又没有子节点代表这是一个空标签，不管旧节点里面是否有内容，清空即可。


### 更新节点的命中算法
- 新前旧前
- 新后旧后
- 新后旧前（此种情况发生，将新节点移动到旧后之后）
- 新前旧后（此种情况发生，将新节点移动到旧前之前）

while(新前<=新后 && 旧前<=旧后){ 命中算法 }if( 新前 > 新后 ){ 其余项删除 }if( 旧前 > 旧后 ){ 添加节点 }
![命中算法：第一种，新前==旧前](./命中-1.png)
命中算法：第一种，新前==旧前，匹配成功，新前index++，旧前index++；新前>新后，其余项删除
![命中算法：第一种，新前==旧前](./命中-2.png)
命中算法：第一种，新前==旧前，匹配成功，新前index++，旧前index++；旧前>旧后，新增节点
![命中算法：](./命中-3.png)
```
过程：
新前-旧前没匹配上
新后-旧后没匹配上
新后-旧前没匹配上
4- 新前-旧后匹配上了,将E移动到旧前之前，原来的E就undefined了， 新前index++，旧后index--
再次匹配
4种匹配都没匹配上，用循环，旧节点中找C,找到之后将C移动到旧前之前，原来的C改为undefined。新前index++
再次匹配
4种匹配都没匹配上，用循环，旧节点中找M,找不到，把M插入到旧前之前
新前 > 新后 ,旧节点中其余项删除
```