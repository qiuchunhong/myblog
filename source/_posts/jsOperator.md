---
title: JavaScript 中的相等操作符 ( 详解 [] == []、[] == ![]、{} == !{} )
categories: js
tags: [js] #文章标签，可空，多标签请用格式，注意:后面有个空格
summary: 
---

相等操作符会先转换操作数（通常称为强制转型），然后比较它们的相等性。

在转换不同的数据类型时，相等操作符遵循下列基本规则：

1. 如果有一个操作数是布尔值，则在比较相等性之前，将其转换为数值；

2. 如果一个操作数是字符串，另一个操作数是数值，在比较之前先将字符串转换为数值；

3. 如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf() 方法，用得到的基本类型值按照前面的规则进行比较；

4. 如果有一个操作数是 NaN，无论另一个操作数是什么，相等操作符都返回 false；

5. 如果两个操作数都是对象，则比较它们是不是同一个对象。如果指向同一个对象，则相等操作符返回 true；

6. 在比较相等性之前，不能将 null 和 undefined 转成其他值。

7. null 和 undefined 是相等的。


## 一、基本规则

上面阐述的 1、2、3 三条规则，总结成一句话就是：

如果相等操作符两边的操作数，不包含 null 或者 undefined，且两个操作数不全是对象，
在执行相等比较之前，会先调用 Number() 将两个操作数强制转为 Number 类型，然后进行比较
所以在使用相等操作符的时候，会有以下情况：
```javascript
'55' == 55;       //Number('55') == 55 -> true
false == 0;       //Number(false) == 0 -> true
"wise" == 3;      //Number("wise") == 3 -> NaN == 3 -> false
[] == 0;          //Number([]) == 0 -> 0 == 0 -> true
```

但是在特殊情况下，也就是两边都有对象的时候，会产生看似不合理的结果：
```javascript
NaN == NaN;  //false （参考第4条规则）
[] == [];    //false
[] == ![];   //true
{} == {};    //false
{} == !{};   //false
```


## 二、[] == [] 和 {} == {}

在 JavaScript 中，<b>Object、Array、Function、RegExp、Date 都是引用类型</b>

声明引用类型的时候，变量名保存在 js 的<b>栈内存</b>里面，而对应的值保存在<b>堆内存</b>里面

而这个变量在栈内存中实际保存的是：这个值在堆内存中的地址，也就是指针

所以 [] == [] 、{} == {} 都为false。

<b>如果两个对象指向同一个对象，相等操作符返回 true</b>

```javascript
let a =b;
b == a;  // true（变量a保存的是b的指针，它们指向同一个对象）
```

## 三、[] == ![] 和 {} == !{}
> ECMAScript 中规定，<b>逻辑非 (!) </b>的优先级高于<b>相等操作符 ( == )</b>

在比较 [] == ![] 的时候，先计算 ![] 得到布尔值 false

所以实际上比较的是 [] == false

然后根据上面的第1条规则和第3条规则，将两个操作数转为数值类型：
```javascript
Number([]) == Number(false);   // ->  0 == 0  ->  true
```

在比较 {} == !{} 的时候，也是遵守同样的规则：
```javascript
{} == !{}
->  {} == Boolean(!{})
->  {} == false
->  Number({}) == Number(false)
->  NaN == 0
->  false
```
然后第4条规则规定：<b>如果有一个操作数是 NaN，相等操作符返回 false</b>

所以 {} == !{} 的结果是 false

## 其他

```javascript
Boolean([]) // true
Boolean({}) // true
Number([])  // 0
Number({})  // NaN
```